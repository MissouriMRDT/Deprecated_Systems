//Using the TI NDK API
//
//
//

/* XDCtools Header files */
#include <xdc/std.h>
#include <xdc/cfg/global.h>
#include <xdc/runtime/Error.h>
#include <xdc/runtime/Memory.h>
#include <xdc/runtime/System.h>

/* BIOS Header files */
#include <ti/sysbios/BIOS.h>
#include <ti/sysbios/knl/Clock.h>
#include <ti/sysbios/knl/Task.h>

 /* NDK Header files */
#include <ti/ndk/inc/netmain.h>
#include <ti/ndk/inc/_stack.h>

/* TI-RTOS Header files */
#include <ti/drivers/GPIO.h>

/* Example/Board Header files */
#include "Board.h"

#define TCPPACKETSIZE 1024
#define TCPPORT 4500
#define NUM_CLIENT_QUEU_CAN_HANDLE 3

Void rove_tcp_handler(UArg arg0, UArg arg1)
{

	//open file descriptor environment in this Taks's private memory (we declare at comile time, so this a stack frame. Task_Create() woud use a Heap.
	//this is memory space for 16 socket structures. We only use one
	//TaskSelf returns a handle to rove_tcp_handler, much like .this
    fdOpenSession(TaskSelf());

    //created our listen_handshake_socket
    SOCKET listen_handshake_socket;

    //lets see how this looks intitialized
    System_printf("\n");
    System_printf("listen handshake socket = %d",listen_handshake_socket);
    System_printf("\n");

    // SysMin will only print to the console when you call flush or exit
    System_flush();

    //AF_INET			-	ipv4 config (as opposed to ipv6)
    //SOCK_STREAM		-	connection type of socket (as opposed to raw sockets, datagram, etc)
    //IPPROTO_TCP		- 	tcp and ip protocol (as opposed to udp, etc)
    //If socket() succeeds, the function returns a file descriptor representing the socket
    //Otherwise, a value of INVALID_SOCKET (TI's constant for an NDK API error conditions not -1) is returned and the function fdError() returns the type of error
    listen_handshake_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (listen_handshake_socket < 0) {
        System_printf("socket() failed\n");
        Task_exit();
        return;
    }//endif

    //lets see what fdstatus has to see about our socket
    //fdstatus returns 0, so we are init to 111 just for any number that is NOT a fdstatus
    int fd_listen_handshake_socket_status = 111;

    //fdstatus returns 0 for success and writes the error integer into arg3 &fd_listen_handshake_socket_statu
    int fdstatusWorks =	fdstatus(listen_handshake_socket, FDSTATUS_RECV, &fd_listen_handshake_socket_status);
    System_printf("\n");
    System_printf("fd listen handshake status = %d", fd_listen_handshake_socket_status);
    System_printf("\n");
    // SysMin will only print to the console when you call flush or exit */
    System_flush();

    //We have now instatiated and defined a socket

    //Define our Struct for Socket Address Information on the File Description Environment
    //We really only care about IP ADDRESS and PORT. Everything else is basic config for ip tcp
    struct sockaddr_in sLocalAddr;

    //memset is seting this structure to zero
    memset((char *)&sLocalAddr, 0, sizeof(sLocalAddr));

    //AF_INET			-	ipv4 config (as opposed to ipv6)
    sLocalAddr.sin_family = AF_INET;

    sLocalAddr.sin_len = sizeof(sLocalAddr);

    //INADDR_ANY		-	0.0.0.0.0.0 implies we listen to ANY IP at this port
    //htonl				-	host to network long. This flips the byte order b/c the network transport layer needs them backwards (endianess)
    sLocalAddr.sin_addr.s_addr = htonl(INADDR_ANY);

    //hardcodeing the Rove Red Port
    sLocalAddr.sin_port = htons(TCPPORT);

    //lets see what bindStatus has to see about our socket
    //bind() returns 0, so we are init to 111 just for any number that is NOT a fdstatus
    int bindStatus = 111;

    //If bind() succeeds, this function returns 0
    //Otherwise, a value of -1 is returned and the function errno() returns the type of error
    bindStatus = bind(listen_handshake_socket, (struct sockaddr *)&sLocalAddr, sizeof(sLocalAddr));
    	if (bindStatus < 0) {
            System_printf("bind() failed\n");
            fdClose(listen_handshake_socket);
            Task_exit();
            return;
        }//endif


    //bindstatus returns 0 for success and writes the error integer into arg3 &fd_listen_handshake_socket_statu
    System_printf("\n");
    System_printf("listen handshake bind status = %d", bindStatus);
    System_printf("\n");
    //SysMin will only print to the console when you call flush or exit */
    System_flush();

    //lets see what fdstatus has to see about our socket now
    //fdstatus returns 0, so we are init to 111 just for any number that is NOT a fdstatus
    fd_listen_handshake_socket_status = 111;
    fdstatusWorks = 111;
    //fdstatus returns 0 for success and writes the error integer into arg3 &fd_listen_handshake_socket_statu
    fdstatusWorks =	fdstatus(listen_handshake_socket, FDSTATUS_RECV, &fd_listen_handshake_socket_status);
    System_printf("\n");
    System_printf("fd listen handshake status = "%d", fd_listen_handshake_socket_status);
    System_printf("\n");
    // SysMin will only print to the console when you call flush or exit */
    System_flush();


    fdClose(listen_handshake_socket);
    Task_exit();


}//endfnct rove_tcp_handler



