//	Using the Texas Instruments (TI) Network Developement Kit (NDK) Application Programmer Interface
//
//	Strict adherence to the TI NDK API OS App layer abstraction
//
//	Getting Started NDK - (skip to page 63)		www/ti.com/lit/an/spraax4.pdf
//
//	Full NDK User Guide -						www.ti.com/lit/ug/spru523i.pdf
//
//	NDK FULL API Define -						www.ti.com/lit/ug/spru524i.pdf
//
//  RTOS TI Kernel v6.4 -						www.ti.com/lit/ug/spruex3o/spruex3o.pdf
//
//
//
//	Inline declaration stylistics and system flushing purely for developement purpose
//
//
//	Think of the Base Station(RED) as the Rover's Client. rove_so_tcp_handler is our internal rtos tcp ip Server
//
//
//	Robot Martian Logic Layer:		Created Jan.2015:		MRDT:	Owen, Connor, Judah, G_Zuess_2014
//
//	Last Edited:					Jan.2015				MRDT:	Judah

#include "listen_handshake_tcp_ip_proto.h"

//		TI defines macro value using the smallest addressable unit. This is a byte for us on the Tiva C 1294

#define TCPPACKETSIZE 1024
#define RED_CLIENT_PORT 4500
#define NUM_CLIENT_QUEU_CAN_HANDLE 3

// 	rove_so_tcp_handler fronts as rtos scheduled handler in forever loop state with prioirity and implicit blocking
//  On a preallocated Stack in the NDK API Network TASK at RTOS init
//
// 			via TIRTOS.PRODUCTS.SYSBIOS.SCHEDULING.TASK_INSTANCE
//			and TIRTOS.PRODUCTS.NDK.NETWORK.SCHEDULING.SCHEDULING_OPTIONS
//
// 	See tcpEcho.cfg for details
//
//			Or navigate the CCS cnfg Gui path panes (i.e. Available Products->NDK>NETWORK>SCHEDULING ..etc)
//			(via XDCTools and XConfig rtsc markup bundles installed for eclispse)

Void rove_so_tcp_handler(UArg arg0, UArg arg1){

	// File descriptor environment in this Task's private memory

		System_printf("\n");
		System_printf("Opening file descriptor environment");
		System_printf("\n");

	// Will only print to the console when you call flush or exit (SysMin)

	System_flush()

	// This is in the compile time task private stack frame. Task_Create() woud use a runtime dynamic Heap.

	// 		TaskSelf() returns a handle to rove_tcp_handler, much like .this
	// 		This is memory space for 16 socket structures.
	// 		We only use two socket structs in roveSoNet, listen, and accept.

	// 		listen passes accept this file descriptor (fd) context by reference
	// 		accept then periodically polls the client for stay alive vs reconnect and reload
	// 		listen blocks idle but will implicitly awake on client connects in ndk NETCTRL and NTLTOOL lower layer scheduling
	// 		accept can clear context, reset, and re-inherent the listen context at connection loss

	// 		We only use two keep_alive instances of the fd environment
	// 		A single listen socket and a single accept socket

    fdOpenSession(TaskSelf());

    // create our listen_handshake_socket

    SOCKET listen_handshake_socket;

    // lets see how this looks intitialized. It should be init as INVALID_SOCKET (-1) state for disqualify use

    	System_printf("\n");
    	System_printf("Instantiating the listen_handshake_socket = %d",listen_handshake_socket);
    	System_printf("\n");

    // Will only print to the console when you call flush or exit (SysMin)

    System_flush();

    // AF_INET			-	defined bsd standard for ipv4 config (as opposed to ipv6)
    // SOCK_STREAM		-	defined bsd standard for connection type of socket (as opposed to raw sockets, datagram, etc)
    // IPPROTO_TCP		- 	defined bsd standard for tcp and ip protocol (as opposed to udp, etc)

    //			If socket() succeeds, it returns a file descriptor (valued int) to represent the socket
    //			Otherwise, a value of INVALID_SOCKET is returned and the function fdError() can be used to return the type of error

    listen_handshake_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

    	if (listen_handshake_socket < 0) {
    		System_printf("socket() failed\n");
    		Task_exit();
    	return;
    	}//endif

    	System_printf("\n");
    	System_printf("This for listen_handshake_socket after socket() = %d", listen_handshake_socket);
    	System_printf("\n");
    	System_flush();


    // 0 is already reserved for fdStatus.return therefore we are initializing to 111 purely arbitrarily

      int fd_listen_handshake_socket_status = 111;

    // FDSTATUS_RECV	-	means what def details? TODO

    // 			fdstatus returns 0 for success and writes the error integer into our memory location
    //			We pass &fd_listen_handshake_socket_status for reference

      	  fdStatus(listen_handshake_socket, FDSTATUS_RECV, &fd_listen_handshake_socket_status);

      	  System_printf("\n");
      	  System_printf("file descripter for listen_handshake_socket after socket() = %d", fd_listen_handshake_socket_status);
      	  System_printf("\n");
      	  System_flush();

      	  System_printf("\n");
      	  System_printf("We have now allocated and instatiated a socket");
      	  System_printf("\n");
      	  System_flush();

    //	Define our Struct for Socket Address Information on the file description Eevironment in socket 1 of the 16 frame
    //			We really only care about IP ADDRESS and PORT. Everything else is basic config for bsd socket on ip/tcp

    struct sockaddr_in socket_local_addr;

    // memset is init setting this Socket Address Information structure to zero

    memset((char *)&socket_local_addr, 0, sizeof(socket_local_addr));

    // AF_INET			-	defined standard for ipv4 config (as opposed to ipv6)

    socket_local_addr.sin_family = AF_INET;
    socket_local_addr.sin_len = sizeof(socket_local_addr);

    // INADDR_ANY		-	defined bsd standard for 0.0.0.0 implies we listen to ANY IP at this port
    // htonl			-	'host to network long' This flips the byte order b/c the network transport layer needs them backwards (reverse the endianess)

    socket_local_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    // hard coding the port the Client will be connecting to listen and accept from (Base Station RED Software Application)

    //UINT32 LOCAL_PORT_TO_LISTEN =  4500;

    socket_local_addr.sin_port = htons(LOCAL_PORT_TO_LISTEN);

    // lets see what bindStatus has to see about our socket
    // 			bind() r returns 0 for success and writes the error integer into our memory location
    //			We pass listen_handshake_socket to get the context of the

    // bind() returns 0, so we are init to 111 just for any number that is NOT a fdstatus
    int bindStatus = 111;

    // If bind() succeeds, this function returns 0
    //			Otherwise, a value of -1 is returned and the function errno() returns the type of error

    bindStatus = bind(listen_handshake_socket, (struct sockaddr *)&sLocalAddr, sizeof(sLocalAddr));
    	if (bindStatus < 0) {
            System_printf("bind() failed\n");
            fdClose(listen_handshake_socket);
            Task_exit();
            return;
        }//endif

    // lets see what bindStatus has to see about our socket
    // 			bind() r returns 0 for success and writes the error integer into our memory location
    //			We pass listen_handshake_socket to get the context of the

    		System_printf("\n");
    		System_printf("bindStatus for listen_handshake_socket after bind() = %d", bindStatus);
    		System_printf("\n");
    		System_flush();

    // lets see what fdstatus has to see about our socket now

    fd_listen_handshake_socket_status = 111;

    //fdstatus returns 0 for success and writes the error integer into arg3 &fd_listen_handshake_socket_statu

    fdStatus(listen_handshake_socket, FDSTATUS_RECV, &fd_listen_handshake_socket_status);

    System_printf("\n");
    System_printf("fd listen handshake status after bind() = %d", fd_listen_handshake_socket_status);
    System_printf("\n");
    System_flush();


    //NUM_CLIENT_QUEU_CAN_HANDLE	- 	this is set to 3 just b/c we want to be careful about the queue size
    //Our actual App can ONLY handle ONE client. We just have a big queue right now for safe bounds in dev
    //lets see what listenStatus has to see about our socket
    //bind() returns 0, so we are init to 111 just for any number that is NOT a fdstatus
    int listenStatus = 111;

    //If listen succeeds, this function returns 0
    //Otherwise, a value of -1 is returned and the function fdError() returns the type of error
    listenStatus = listen(listen_handshake_socket, NUM_CLIENT_QUEU_CAN_HANDLE);
    	if (listenStatus < 0) {
            System_printf("listen() failed\n");
            fdClose(listen_handshake_socket);
            Task_exit();
            return;
        }//endif


    //bindstatus returns 0 for success and writes the error integer into arg3 &fd_listen_handshake_socket_statu
    System_printf("\n");
    System_printf("listen handshake listenStatus = %d", listenStatus);
    System_printf("\n");
    //SysMin will only print to the console when you call flush or exit */
    System_flush();

    //lets see what fdstatus has to see about our socket now
    //fdstatus returns 0, so we are init to 111 just for any number that is NOT a fdstatus
    fd_listen_handshake_socket_status = 111;
    fdstatusWorks = 111;
    //fdstatus returns 0 for success and writes the error integer into arg3 &fd_listen_handshake_socket_status
    fdstatusWorks =	fdStatus(listen_handshake_socket, FDSTATUS_RECV, &fd_listen_handshake_socket_status);
    System_printf("\n");
    System_printf("fd listen handshake status after listen() = %d", fd_listen_handshake_socket_status);
    System_printf("\n");
    // SysMin will only print to the console when you call flush or exit */
    System_flush();


    //lets see what optionStatus has to see about our socket
    //setsockop() returns 0, so we are init to 111 just for any number that is NOT a fdstatus
    int optionStatus = 111;

    //setsocketopt() needs US to allocate a memory space for the option AND pass it in to the fnctn as arg4 and arg5
    int optval;
    int optlen = sizeof(optval);


    //SOL_SOCKET	-	at the SOCKET level, as opposed to lower layers in teh OSI/TCP heirarchy
    //SO_KEEPALIVE	-	NDK will periodically send a keep alive packet under the hood
    //By default this sends KEEP probes every 75 seconds AFTER two hours of idle
    //TODO change this defaultin the NDK - IP - .cfg options to a MUCH shorter idle time. pg 173 of NDK API spru524i

    //If setsockopt succeeds, this function returns 0
    //Otherwise, a value of -1 is returned and the function errno() returns the type of error
    optionStatus = setsockopt(listen_handshake_socket, SOL_SOCKET, SO_KEEPALIVE, &optval, optlen);
    if (optionStatus < 0) {
            System_printf("setsockoopt() failed\n");
            fdClose(listen_handshake_socket);
            Task_exit();
            return;
        }//endif


    //optionStatus returns 0 for success and writes the error integer into arg3 &fd_listen_handshake_socket_statu
    System_printf("\n");
    System_printf("listen handshake optionStatus = %d", listenStatus);
    System_printf("\n");
    //SysMin will only print to the console when you call flush or exit */
    System_flush();

    //lets see what fdstatus has to see about our socket now
    //fdstatus returns 0, so we are init to 111 just for any number that is NOT a fdstatus
    fd_listen_handshake_socket_status = 111;
    fdstatusWorks = 111;
    //fdstatus returns 0 for success and writes the error integer into arg3 &fd_listen_handshake_socket_status
    fdstatusWorks =	fdStatus(listen_handshake_socket, FDSTATUS_RECV, &fd_listen_handshake_socket_status);
    System_printf("\n");
    System_printf("fd listen handshake status after setsockopt() = %d", fd_listen_handshake_socket_status);
    System_printf("\n");
    // SysMin will only print to the console when you call flush or exit */
    System_flush();

    SOCKET accept_recv_socket;
    struct sockaddr_in accept_recv_socket_addr;
    int accept_recv_socket_addr_len = sizeof(accept_recv_socket);

    //accept() returns positive integer for success and -1 for failure
    accept_recv_socket = accept(listen_handshake_socket, (struct sockaddr_in*)&accept_recv_socket_addr, &accept_recv_socket_addr_len);
    if (accept_recv_socket < 0) {
                System_printf("accept() failed\n");
                fdClose(accept_recv_socket);
                fdClose(listen_handshake_socket);
                Task_exit();
                return;
            }//endif


    //accept() returns positive integer for success and -1 for failure
       System_printf("\n");
       System_printf("after accept() accept_recv_socket = %d", accept_recv_socket);
       System_printf("\n");
       //SysMin will only print to the console when you call flush or exit */
       System_flush();

       //lets see what fdstatus has to see about our socket now
       //fdstatus returns 0, so we are init to 111 just for any number that is NOT a fdstatus
       fd_listen_handshake_socket_status = 111;
       fdstatusWorks = 111;
       //fdstatus returns 0 for success and writes the error integer into arg3 &fd_listen_handshake_socket_status
       fdstatusWorks =	fdStatus(listen_handshake_socket, FDSTATUS_RECV, &fd_listen_handshake_socket_status);
       System_printf("\n");
       System_printf("fd listen handshake status after accept() = %d", fd_listen_handshake_socket_status);
       System_printf("\n");
       // SysMin will only print to the console when you call flush or exit */
       System_flush();


    fdClose(listen_handshake_socket);
    Task_exit();


}//endfnct rove_tcp_handler



