#include "i2c.h"

// Initialize Class Variables //////////////////////////////////////////////////

uint8_t Wire::rxBuffer[BUFFER_LENGTH];
uint8_t Wire::rxBufferIndex = 0;
uint8_t Wire::rxBufferLength = 0;

uint8_t Wire::txAddress = 0;
uint8_t Wire::txBuffer[BUFFER_LENGTH];
uint8_t Wire::txBufferIndex = 0;
uint8_t Wire::txBufferLength = 0;

uint8_t Wire::transmitting = 0;

// Constructors ////////////////////////////////////////////////////////////////

Wire::Wire() {
}

// Public Methods //////////////////////////////////////////////////////////////

void Wire::init(void) {
	rxBufferIndex = 0;
	rxBufferLength = 0;

	txBufferIndex = 0;
	txBufferLength = 0;

	/* Initialize the I2C bus (i2c_app_init) */
	I2C_ID_T id = I2C0; // Select I2C peripheral
	static I2C_ID_T i2cDev = I2C0;

	// Init I2C Pin Mux (Init_I2C_PinMux)
#if (defined(BOARD_NXP_XPRESSO_11U14) || defined(BOARD_NGX_BLUEBOARD_11U24))
	Chip_SYSCTL_PeriphReset(RESET_I2C0);
	Chip_IOCON_PinMuxSet(LPC_IOCON, 0, 4, IOCON_FUNC1 | I2C_FASTPLUS_BIT);
	Chip_IOCON_PinMuxSet(LPC_IOCON, 0, 5, IOCON_FUNC1 | I2C_FASTPLUS_BIT);
#elif (defined(BOARD_NXP_XPRESSO_11C24) || defined(BOARD_MCORE48_1125))
	Chip_SYSCTL_PeriphReset(RESET_I2C0);
	Chip_IOCON_PinMuxSet(LPC_IOCON, IOCON_PIO0_4, IOCON_FUNC1 | I2C_FASTPLUS_BIT);
	Chip_IOCON_PinMuxSet(LPC_IOCON, IOCON_PIO0_5, IOCON_FUNC1 | I2C_FASTPLUS_BIT);
#else
#error "No Pin Muxing defined for I2C operation"
#endif

	// Initialize I2C
	Chip_I2C_Init(id);
	Chip_I2C_SetClockRate(id, speed);

	// Set I2C mode to polling/interrupt (i2c_set_mode)
	i2cSetMode(id, 0); // Set default mode to interrupt

	/* Simulate IO Expansion slave (i2c_iox_init) */
#ifndef CHIP_LPC11CXX
	Board_Buttons_Init();
#endif
	agXfer.slaveAddr = (I2C_SLAVE_AG_ADDR << 1);
	agXfer.rxBuff = &ag_data[1];
	agXfer.rxSz = sizeof(ag_data);
	agXfer.txBuff = (const uint8_t *) ag_data;
	agXfer.txSz = sizeof(ag_data) + 1;
	Chip_I2C_SlaveSetup(id, I2C_SLAVE_0, &ag_xfer, i2c_ag_events, 0);
	int ops = 3;
	if (ops & 1) {	// update out port
		Board_LED_Set(0, ag_data[1] & 1);
		Board_LED_Set(1, ag_data[1] & 2);
		Board_LED_Set(2, ag_data[1] & 4);
		Board_LED_Set(3, ag_data[1] & 8);
	}
#ifndef CHIP_LPC11CXX
	if (ops & 2) {	// update in port
		ag_data[0] = (uint8_t) Buttons_GetStatus();
	}
#endif
	// Setup SysTick timer to get the button status updated at regular intervals
	SysTick_Config(Chip_Clock_GetSystemClockRate() / 50);

	mXfer.slaveAddr = (I2C_SLAVE_M_ADDR << 1);
	mXfer.rxBuff = &m_data[1];
	mXfer.rxSz = sizeof(m_data);
	mXfer.txBuff = (const uint8_t *) m_data;
	mXfer.txSz = sizeof(m_data) + 1;
	Chip_I2C_SlaveSetup(id, I2C_SLAVE_1, &m_xfer, i2c_m_events, 0);
	int ops = 3;
	if (ops & 1) {	// update out port
		Board_LED_Set(0, m_data[1] & 1);
		Board_LED_Set(1, m_data[1] & 2);
		Board_LED_Set(2, m_data[1] & 4);
		Board_LED_Set(3, m_data[1] & 8);
	}
#ifndef CHIP_LPC11CXX
	if (ops & 2) {	// update in port
		m_data[0] = (uint8_t) Buttons_GetStatus();
	}
#endif
	// Setup SysTick timer to get the button status updated at regular intervals
	SysTick_Config(Chip_Clock_GetSystemClockRate() / 50);

	/* Select I2C peripheral */
	i2cDev = I2C0;


}

void Wire::beginTransmission(uint8_t address) {
	// indicate that we are transmitting
	transmitting = 1;
	// set address of targeted slave
	txAddress = address;
	// reset tx buffer iterator vars
	txBufferIndex = 0;
	txBufferLength = 0;
}

//
//	Originally, 'endTransmission' was an f(void) function.
//	It has been modified to take one parameter indicating
//	whether or not a STOP should be performed on the bus.
//	Calling endTransmission(false) allows a sketch to
//	perform a repeated start.
//
//	WARNING: Nothing in the library keeps track of whether
//	the bus tenure has been properly ended with a STOP. It
//	is very possible to leave the bus in a hung state if
//	no call to endTransmission(true) is made. Some I2C
//	devices will behave oddly if they do not see a STOP.
//
uint8_t Wire::endTransmission(uint8_t sendStop) {
	// transmit buffer (blocking)
	int8_t ret = twi_writeTo(txAddress, txBuffer, txBufferLength, 1, sendStop);
	// reset tx buffer iterator vars
	txBufferIndex = 0;
	txBufferLength = 0;
	// indicate that we are done transmitting
	transmitting = 0;
	return ret;
}

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t Wire::write(uint8_t data) {
	if (transmitting) {
		// in master transmitter mode
		// don't bother if buffer is full
		if (txBufferLength >= BUFFER_LENGTH) {
			// buffer full
			return 0;
		}
		// put byte in tx buffer
		txBuffer[txBufferIndex] = data;
		++txBufferIndex;
		// update amount in buffer
		txBufferLength = txBufferIndex;
	} else {
		// in slave send mode
		// reply to master
		twi_transmit(&data, 1);
	}
	return 1;
}

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int Wire::read(void) {
	int value = -1;

	// get each successive byte on each call
	if (rxBufferIndex < rxBufferLength) {
		value = rxBuffer[rxBufferIndex];
		++rxBufferIndex;
	}

	return value;
}

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int Wire::isAvailable(void) {
	return rxBufferLength - rxBufferIndex;
}

// Preinstantiate Objects //////////////////////////////////////////////////////
Wire i2c = Wire();

